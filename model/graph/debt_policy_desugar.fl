bound_asset_type debt {} issued_by lender;

// global_params are given at policy instantiation time

global_param interest_rate: Fraction
  { interest_rate > 0; interest_rate < 1; };
global_param fiat: ResourceType;
global_param borrower: Identity;
// global_param lender: Identity;
global_param loan_amount: Amount;

txn start_loan(out resource the_debt:  debt,
               out resource the_money: fiat,
               in  resource money_src: fiat,
)
  ensures the_debt.amount == the_money.amount;
  ensures the_debt.amount == loan_amount;
{
  require_signature borrower;
  require_signature lender;

  assert money_src.amount == loan_amount;
  assert the_money.owner  == borrower;
  assert the_debt.owner   == lender;
  transfer loan_amount of money_src -> the_money;
  issue    loan_amount of debt      -> the_debt;
}

txn repay_loan(inout resource the_debt:    debt,
               in    resource payment_src: fiat,
               out   resource payment_dst: fiat,
)
  ensures the_debt.amount <= old(the_debt.amount);
{
  // assert payment_dst.owner == lender;
  assert payment_dst.owner == the_debt.owner;

  // TODO: time?
  local interest_amt = round(the_debt.amount * interest_rate);
  assert payment_src.amount >= interest_amt;

  local burn_amt = payment_src.amount - interest_amt; // Amount
  local remainder = the_debt.amount - burn_amt;

  transfer burn_amt  of the_debt -> BURN_ADDRESS;
  transfer remainder of the_debt -> the_debt; // implicit?
  transfer ALL of payment_src -> payment_dst;
}

======================================================================
explicit init check
======================================================================

bound_asset_type debt {} issued_by lender;

// global_params are given at policy instantiation time

global_param interest_rate: Fraction
  { interest_rate > 0; interest_rate < 1; };
global_param fiat: ResourceType;
global_param borrower: Identity;
global_param loan_amount: Amount;

init_check()
{
}


txn start_loan(out resource the_debt:  debt,
               out resource the_money: fiat,
               in  resource money_src: fiat,
)
  ensures the_debt.amount == the_money.amount;
  ensures the_debt.amount == loan_amount;
{
  require_signature borrower;
  require_signature lender;

  assert money_src.amount == loan_amount;
  assert the_money.owner  == borrower;
  assert the_debt.owner   == lender;
  transfer loan_amount of money_src -> the_money;
  issue    loan_amount of debt      -> the_debt;
}

txn repay_loan(inout resource the_debt:    debt,
               in    resource payment_src: fiat,
               out   resource payment_dst: fiat,
)
  ensures the_debt.amount <= old(the_debt.amount);
{
  // assert payment_dst.owner == lender;
  assert payment_dst.owner == the_debt.owner;

  // TODO: time?
  local interest_amt = round(the_debt.amount * interest_rate);
  assert payment_src.amount >= interest_amt;

  local burn_amt = payment_src.amount - interest_amt; // Amount
  local remainder = the_debt.amount - burn_amt;

  transfer burn_amt  of the_debt -> BURN_ADDRESS;
  transfer remainder of the_debt -> the_debt; // implicit?
  transfer ALL of payment_src -> payment_dst;
}

======================================================================
explicit asserts
======================================================================

bound_asset_type debt {} issued_by lender;

global_param interest_rate: Fraction;
global_param fiat: ResourceType;
global_param borrower: Identity;
global_param loan_amount: Amount;

init_check()
{
  assert interest_rate > 0;
  assert interest_rate < 1;
}


txn start_loan(out resource the_debt:  debt,
               out resource the_money: fiat,
               in  resource money_src: fiat,
)
{
  require_signature borrower;
  require_signature lender;

  assert money_src.amount == loan_amount;
  assert the_money.owner  == borrower;
  assert the_debt.owner   == lender;

  assert loan_amount >= 0;
  assert loan_amount <= money_src.amount;
  transfer loan_amount of money_src -> the_money;
  assert loan_amount >= 0;
  issue    loan_amount of debt      -> the_debt;

  assert the_debt.amount == the_money.amount;
  assert the_debt.amount == loan_amount;
  assert money_src.amount == 0;
}

txn repay_loan(inout resource the_debt:    debt,
               in    resource payment_src: fiat,
               out   resource payment_dst: fiat,
)
{
  assert payment_dst.owner == the_debt.owner;

  local interest_amt = round(the_debt.amount * interest_rate);
  assert payment_src.amount >= interest_amt;

  local burn_amt = payment_src.amount - interest_amt;
  local remainder = the_debt.amount - burn_amt;

  assert burn_amt >= 0;
  assert burn_amt <= the_debt.amount;
  transfer burn_amt  of the_debt -> BURN_ADDRESS;
  assert remainder >= 0;
  assert remainder <= the_debt.amount;
  transfer remainder of the_debt -> the_debt;
  transfer ALL of payment_src -> payment_dst;

  assert the_debt.amount <= old(the_debt.amount);
  assert in(the_debt).amount == 0; // hrm...
  assert payment_src.amount == 0;
}

======================================================================
expression substitution
======================================================================

bound_asset_type debt {} issued_by lender;

global_param interest_rate: Fraction;
global_param fiat: ResourceType;
global_param borrower: Identity;
global_param loan_amount: Amount;

init_check()
{
  assert interest_rate > 0;
  assert interest_rate < 1;
}


txn start_loan(out resource the_debt:  debt,
               out resource the_money: fiat,
               in  resource money_src: fiat,
)
{
  require_signature borrower;
  require_signature lender;

  assert money_src.amount == loan_amount;
  assert the_money.owner  == borrower;
  assert the_debt.owner   == lender;
  transfer loan_amount of money_src -> the_money;
  issue    loan_amount of debt      -> the_debt;

  assert new(the_debt.amount) == new(the_money.amount);
  assert new(the_debt.amount) == loan_amount;
  assert old(money_src.amount)-loan_amount == 0;
}

txn repay_loan(inout resource the_debt:    debt,
               in    resource payment_src: fiat,
               out   resource payment_dst: fiat,
)
{
  assert payment_dst.owner == the_debt.owner;

  // local interest_amt = round(old(the_debt.amount) * interest_rate);
  assert payment_src.amount >= round(old(the_debt.amount) * interest_rate);

  // local burn_amt = payment_src.amount - round(old(the_debt.amount) * interest_rate);
  // local remainder = old(the_debt.amount) - (payment_src.amount - round(old(the_debt.amount) * interest_rate));
  // assert remainder: Amount ?

  assert payment_src.amount - round(old(the_debt.amount) * interest_rate) >= 0;
  assert payment_src.amount - round(old(the_debt.amount) * interest_rate) <= old(the_debt.amount);
  transfer (payment_src.amount
            - round(old(the_debt.amount) * interest_rate))
          of the_debt -> BURN_ADDRESS;

  assert old(the_debt.amount) - (payment_src.amount - round(old(the_debt.amount) * interest_rate)) >= 0;
  assert old(the_debt.amount) - (payment_src.amount - round(old(the_debt.amount) * interest_rate)) <= old(the_debt.amount);
  transfer (old(the_debt.amount)
            - (payment_src.amount - round(old(the_debt.amount) * interest_rate)))
           of the_debt -> the_debt;
  // timestamp these reads?
  transfer old(payment_src.amount) of payment_src -> payment_dst;

  assert new(the_debt.amount) <= old(the_debt.amount);
  assert old(the_debt.amount)
          - ((new(payment_src.amount)
             - round(old(the_debt.amount) * interest_rate))
             + (old(the_debt.amount)
                - (old(payment_src.amount)
                   - round(old(the_debt.amount) * interest_rate))
               )
            ) == 0;
  assert new(payment_src.amount) == 0;
}

======================================================================
type desugar
======================================================================

bound_asset_type debt {} issued_by lender;

global_param interest_rate: Fraction;
global_param fiat: ResourceType;
global_param borrower: Identity;
global_param loan_amount: Amount;

init_check()
{
  // type declarations for bound_asset_type?
  assert valid_ResourceType(debt);
  // assert debt.policy == THIS_POLICY;
  assert valid_Identity(lender);
  assert debt.issuer == lender;

  // Maybe these are truly implicit?
  assert valid_Fraction(interest_rate);
  assert valid_ResourceType(fiat);
  assert valid_Identity(borrower);
  assert valid_Amount(loan_amount);

  assert interest_rate > 0;
  assert interest_rate < 1;
}


txn start_loan(out resource the_debt,
               out resource the_money,
               in  resource money_src,
)
{
  assert the_debt.asset_type == debt;
  assert the_money.asset_type == fiat;
  assert money_src.asset_type == fiat;

  require_signature borrower;
  require_signature lender;

  assert money_src.amount == loan_amount;
  assert the_money.owner  == borrower;
  assert the_debt.owner   == lender;
  transfer loan_amount of money_src -> the_money;
  issue    loan_amount of debt      -> the_debt;

  assert new(the_debt.amount) == new(the_money.amount);
  assert new(the_debt.amount) == loan_amount;
  assert old(money_src.amount)-loan_amount == 0;
}

txn repay_loan(inout resource the_debt,
               in    resource payment_src,
               out   resource payment_dst,
)
{
  assert the_debt.asset_type == debt;
  assert payment_src.asset_type == fiat;
  assert payment_dst.asset_type == fiat;

  assert payment_dst.owner == the_debt.owner;

  assert payment_src.amount >= round(old(the_debt.amount) * interest_rate);

  assert payment_src.amount - round(old(the_debt.amount) * interest_rate) >= 0;
  assert payment_src.amount - round(old(the_debt.amount) * interest_rate) <= old(the_debt.amount);
  transfer (payment_src.amount
            - round(old(the_debt.amount) * interest_rate))
          of the_debt -> BURN_ADDRESS;

  assert old(the_debt.amount) - (payment_src.amount - round(old(the_debt.amount) * interest_rate)) >= 0;
  assert old(the_debt.amount) - (payment_src.amount - round(old(the_debt.amount) * interest_rate)) <= old(the_debt.amount);
  transfer (old(the_debt.amount)
            - (payment_src.amount - round(old(the_debt.amount) * interest_rate)))
           of the_debt -> the_debt;
  // timestamp these reads?
  transfer old(payment_src.amount) of payment_src -> payment_dst;

  assert new(the_debt.amount) <= old(the_debt.amount);
  assert old(the_debt.amount)
          - ((new(payment_src.amount)
             - round(old(the_debt.amount) * interest_rate))
             + (old(the_debt.amount)
                - (old(payment_src.amount)
                   - round(old(the_debt.amount) * interest_rate))
               )
            ) == 0;
  assert new(payment_src.amount) == 0;
}

======================================================================
inout desugar
======================================================================

bound_asset_type debt {} issued_by lender;

global_param interest_rate: Fraction;
global_param fiat: ResourceType;
global_param borrower: Identity;
global_param loan_amount: Amount;

init_check()
{
  // type declarations for bound_asset_type?
  assert valid_ResourceType(debt);
  // assert debt.policy == THIS_POLICY;
  assert valid_Identity(lender);
  assert debt.issuer == lender;

  // Maybe these are truly implicit?
  assert valid_Fraction(interest_rate);
  assert valid_ResourceType(fiat);
  assert valid_Identity(borrower);
  assert valid_Amount(loan_amount);

  assert interest_rate > 0;
  assert interest_rate < 1;
}


txn start_loan(out resource the_debt,
               out resource the_money,
               in  resource money_src,
)
{
  assert the_debt.asset_type == debt;
  assert the_money.asset_type == fiat;
  assert money_src.asset_type == fiat;

  require_signature borrower;
  require_signature lender;

  assert money_src.amount == loan_amount;
  assert the_money.owner  == borrower;
  assert the_debt.owner   == lender;
  transfer loan_amount of money_src -> the_money;
  issue    loan_amount of debt      -> the_debt;

  assert new(the_debt.amount) == new(the_money.amount);
  assert new(the_debt.amount) == loan_amount;
  assert old(money_src.amount)-loan_amount == 0;
}

txn repay_loan(in    resource the_debt_in,
                 out resource the_debt_out,
               in    resource payment_src,
               out   resource payment_dst,
)
{
  assert the_debt.asset_type == debt;
  assert payment_src.asset_type == fiat;
  assert payment_dst.asset_type == fiat;

  assert payment_dst.owner == the_debt.owner;

  assert payment_src.amount >= round(old(the_debt.amount) * interest_rate);

  assert payment_src.amount - round(old(the_debt.amount) * interest_rate) >= 0;
  assert payment_src.amount - round(old(the_debt.amount) * interest_rate) <= old(the_debt.amount);
  transfer (payment_src.amount
            - round(old(the_debt.amount) * interest_rate))
          of the_debt_in -> BURN_ADDRESS;

  assert old(the_debt.amount) - (payment_src.amount - round(old(the_debt.amount) * interest_rate)) >= 0;
  assert old(the_debt.amount) - (payment_src.amount - round(old(the_debt.amount) * interest_rate)) <= old(the_debt.amount);
  transfer (old(the_debt.amount)
            - (payment_src.amount - round(old(the_debt.amount) * interest_rate)))
           of the_debt_in -> the_debt_out;
  // timestamp these reads?
  transfer old(payment_src.amount) of payment_src -> payment_dst;

  assert new(the_debt.amount) <= old(the_debt.amount);
  assert old(the_debt.amount)
          - ((new(payment_src.amount)
             - round(old(the_debt.amount) * interest_rate))
             + (old(the_debt.amount)
                - (old(payment_src.amount)
                   - round(old(the_debt.amount) * interest_rate))
               )
            ) == 0;
  assert new(payment_src.amount) == 0;
}

======================================================================
patternize
======================================================================

bound_asset_type debt {} issued_by lender;

global_param interest_rate: Fraction;
global_param fiat: ResourceType;
global_param borrower: Identity;
global_param loan_amount: Amount;

init_check()
{
  // type declarations for bound_asset_type?
  assert valid_ResourceType(debt);
  // assert debt.policy == THIS_POLICY;
  assert valid_Identity(lender);
  assert debt.issuer == lender;

  // Maybe these are truly implicit?
  assert valid_Fraction(interest_rate);
  assert valid_ResourceType(fiat);
  assert valid_Identity(borrower);
  assert valid_Amount(loan_amount);

  assert interest_rate > 0;
  assert interest_rate < 1;
}

txn start_loan(out resource the_debt,
               out resource the_money,
               in  resource money_src,
)
{
  assert the_debt.asset_type == debt;
  assert the_money.asset_type == fiat;
  assert money_src.asset_type == fiat;

  require_signature borrower;
  require_signature lender;

  assert money_src.amount == loan_amount;
  assert the_money.owner  == borrower;
  assert the_debt.owner   == lender;

  expect {
    transfer ?trn_amount of ?trn_src -> ?trn_dst;
    issue    ?iss_amount of ?iss_type -> ?iss_dst;
  }

  assert trn_amount == loan_amount;
  assert trn_src == money_src;
  assert trn_dst == the_money;

  assert iss_amount == loan_amount;
  assert iss_type == debt;
  assert iss_dst == the_debt;

  // Is this transformation reasonable?
  // assert new(the_debt.amount) == new(the_money.amount);
  assert iss_amount == trn_amount;
  // assert new(the_debt.amount) == loan_amount;
  assert iss_amount == loan_amount;
  assert money_src.amount-loan_amount == 0;
}

txn repay_loan(in    resource the_debt_in,
                 out resource the_debt_out,
               in    resource payment_src,
               out   resource payment_dst,
)
{
  assert the_debt.asset_type == debt;
  assert payment_src.asset_type == fiat;
  assert payment_dst.asset_type == fiat;

  assert payment_dst.owner == the_debt.owner;

  assert payment_src.amount >= round(old(the_debt.amount) * interest_rate);

  assert payment_src.amount - round(old(the_debt.amount) * interest_rate) >= 0;
  assert payment_src.amount - round(old(the_debt.amount) * interest_rate) <= old(the_debt.amount);
  transfer (payment_src.amount
            - round(old(the_debt.amount) * interest_rate))
          of the_debt_in -> BURN_ADDRESS;

  assert old(the_debt.amount) - (payment_src.amount - round(old(the_debt.amount) * interest_rate)) >= 0;
  assert old(the_debt.amount) - (payment_src.amount - round(old(the_debt.amount) * interest_rate)) <= old(the_debt.amount);
  transfer (old(the_debt.amount)
            - (payment_src.amount - round(old(the_debt.amount) * interest_rate)))
           of the_debt_in -> the_debt_out;
  // timestamp these reads?
  transfer old(payment_src.amount) of payment_src -> payment_dst;

  assert new(the_debt.amount) <= old(the_debt.amount);
  assert old(the_debt.amount)
          - ((new(payment_src.amount)
             - round(old(the_debt.amount) * interest_rate))
             + (old(the_debt.amount)
                - (old(payment_src.amount)
                   - round(old(the_debt.amount) * interest_rate))
               )
            ) == 0;
  assert new(payment_src.amount) == 0;
}

============================
============================


{-# LANGUAGE LambdaCase        #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveFunctor     #-}
module Main where
import qualified Data.Text as T
import           Data.List (nub,isPrefixOf,sort)
import qualified Data.Map.Lazy as M
import qualified Text.Parsec   as P
import qualified Text.Parsec.Token as P
import           Text.Parsec.Language (javaStyle)
import           Data.Maybe (maybeToList,fromMaybe)
import           Control.Applicative ((<$>),(<*>),(*>))
import           Control.Monad (join, filterM)
import           System.Directory (getCurrentDirectory, getDirectoryContents, doesFileExist)
import           System.IO (hGetContents,openFile,IOMode(..),hFlush,stdout)
import           System.FilePath.Posix (takeBaseName)

alloyish = P.makeTokenParser $ javaStyle
  { P.reservedNames = [ "sig", "abstract", "extends"
                    , "in", "let", "fun", "pred", "fact", "check"
                    , "all", "one", "some", "no", "sum"
                    , "none", "univ", "ident"
                    , "filter", "map"
                    , "fresh", "setexp", "relexp"
                    ]
  , P.caseSensitive = True
  }

policy_lang = P.makeTokenParser $ javaStyle
  { P.reservedNames = [ "param", "global_param", "local", "resource",
                        "credential", "in", "out", "inout" ,
                        "bound_asset_type", "issued_by", "asset",
                        "txn", "assert", "ensures", "require",
                        "require_signature",
                        "of", "old", "new", "round",
                        "transfer", "issue",
                        "Fraction", "Amount", "Identity", "ResourceType",
                        "ALL", "BURN_ADDRESS", "owner", "amount"
                      ]
  , P.caseSensitive = True
  }

data BoundAssetTypeStmt = BoundAssetTypeStmt { _batsType :: Text, _batsIssuer :: Text }
  deriving (Eq,Show,Read)

data DataType = FractionType
              | ResourceType
              | IdentityType
              | AmountType
  deriving (Eq,Show,Read)

data ArithExpr = ConstAmountExpr   Integer
               | ConstFractionExpr Rational
               | PlusExpr  ArithExpr ArithExpr
               | MinusExpr ArithExpr ArithExpr
               | TimesExpr ArithExpr ArithExpr
               | RoundExpr ArithExpr
               | ArithVar  Text
               | AmountField Text
               | OwnerField Text -- TODO: This isn't arithmetic!
  deriving (Eq,Show,Read)

data BoolExpr = TrueExpr
              | FalseExpr
              | NotExpr (BoolExpr)
              | AndExpr (BoolExpr) (BoolExpr)
              | OrExpr  (BoolExpr) (BoolExpr)
              | EqExpr (ArithExpr) (ArithExpr)
              | GtExpr (ArithExpr) (ArithExpr)
              | GeExpr (ArithExpr) (ArithExpr)
              | LtExpr (ArithExpr) (ArithExpr)
              | LeExpr (ArithExpr) (ArithExpr)
  deriving (Eq,Show,Read)

data GlobalParamDecl = GlobalParamDecl
  { _gparamName :: Text, _gparamType :: DataType
  , _gparamInvs :: [BoolExpr] }
  deriving (Eq,Show,Read)

-- Currently resources only
data TxnParamDecl = TxnParamDecl
  { _txnparamIn :: Bool, _txnparamOut :: Bool
  , _txnparamName :: Text, _txnparamType :: Text }
  deriving (Eq,Show,Read)

data TxnDecl = TxnDecl
  { _txnName :: Text, _txnParams :: [TxnParamDecl], _txnRequires :: [BoolExpr]
  , _txnEnsures :: [BoolExpr], _txnBody :: [TxnStmt] }
  deriving (Eq,Show,Read)

data TxnStmt = AssertStmt BoolExpr
             | RequireSignatureStmt Text
             | LocalStmt Text ArithExpr -- TODO: Currently only arithmetic locals
             | IssueStmt ArithExpr Text Text -- amount of asset-type to resource
             -- amount from resource1 to resource2 (Nothing => burn address)
             | TransferStmt ArithExpr Text (Maybe Text)
  deriving (Eq,Show,Read)

-- data datatype
--   = choice   (maybe text) [(text,datatype)]
--   | record   (maybe text) [(text,datatype)]
--   | number
--   | fraction
--   | namedtype text
--   deriving (eq,show,read)

-- data normeddatatype
--   = normedchoice   (maybe text) [(text,normeddatatype)]
--   | normedrecord   (maybe text) [(text,normeddatatype)]
--   | normednumber
--   | normedfraction
--   deriving (eq,show,read)

-- newtype unitid = unitid integer
--   deriving (eq,show,read)

-- data resourcetype = baseunit unitid
--                   | compound [(text,resourcetype)]
--   deriving (eq,show,read)

-- data policyprogram = policyprogram
--   { constants     :: m.map text (datatype, value)
--   , globalparams  :: m.map text datatype
--   , globalstate   :: m.map text datatypdatae
--   , datatypes     :: m.map text datatype
--   , resourcetypes :: m.map text resourcetype
--   , properties    :: m.map text (map text datatype, [policyexpr])
--   , txns          :: m.map text (map text paramdescr, policystmt)
--   }

-- parsedatatype = (
--   (p.try $ do
--   )


parseop op = do
  theop <- p.operator alloyish
  if theop == op then return () else fail ("expected '" ++ op ++ "'")

setbop op = do
  l <- parseleftsetexp
  parseop op
  r <- parsesetexp
  return (l,r)

setleftbop op = do
  l <- parsesimplesetexp
  parseop op
  r <- parsesimplesetexp
  return (l,r)

parsesimplesetexp
  = foldl1 (\x y -> p.try x p.<|> y) $
  [ p.parens alloyish parsesetexp
  , closureset <$> (parseop "*" *> parsesimplesetexp)
  , oneclosureset <$> (parseop "^" *> parsesimplesetexp)
  , transposeset <$> (parseop "~" *> parsesimplesetexp)
  , atomset <$> (p.identifier alloyish)
  , const noneset <$> (p.reserved alloyish "none")
  , const univset <$> (p.reserved alloyish "univ")
  , const identset <$> (p.reserved alloyish "ident")
  ]

parseleftsetexp
  = foldl1 (\x y -> p.try x p.<|> y) $
  [ uncurry (\x y -> joinset x (closureset y)) <$> setleftbop ".*"
  , uncurry (\x y -> joinset x (oneclosureset y)) <$> setleftbop ".^"
  , parsesimplesetexp
  ]

parsesetexp
  = foldl1 (\x y -> p.try x p.<|> y) $
  [ uncurry joinset <$> setbop "."
  , uncurry prodset <$> setbop "->"
  , uncurry isectset <$> setbop "&"
  , uncurry unionset <$> setbop "+"
  , uncurry diffset <$> setbop "-"
  , do
    -- ctor <- (const filterset <$> p.try (p.reserved alloyish "filter"))
    --         p.<|> (const mapset <$> p.reserved alloyish "map")
    p.reserved alloyish "filter"
    var <- p.identifier alloyish
    parseop ":"
    baseexp <- parsesimplesetexp
    relexp <- p.braces alloyish parserelexp
    relexp <- return $ flip fmap relexp $ \vname ->
      if vname == var then nothing else just vname
    return $ filterset baseexp relexp
  , do
    -- ctor <- (const filterset <$> p.try (p.reserved alloyish "filter"))
    --         p.<|> (const mapset <$> p.reserved alloyish "map")
    p.reserved alloyish "map"
    var <- p.identifier alloyish
    parseop ":"
    baseexp <- parsesimplesetexp
    setexp <- p.braces alloyish parsesetexp
    setexp <- return $ flip fmap setexp $ \vname ->
      if vname == var then nothing else just vname
    return $ mapset baseexp setexp
  , parseleftsetexp
  ]

relbop op = do
  l <- parsesimplerelexp
  parseop op
  r <- parserelexp
  return (l,r)

parsesimplerelexp
  = foldl1 (\x y -> p.try x p.<|> y) $
  [ p.parens alloyish parserelexp
  , norel <$> (p.reserved alloyish "no" *> parsesimplesetexp)
  , somerel <$> (p.reserved alloyish "some" *> parsesimplesetexp)
  , lonerel <$> (p.reserved alloyish "lone" *> parsesimplesetexp)
  , onerel <$> (p.reserved alloyish "one" *> parsesimplesetexp)
  , uncurry eqrel <$> setbop "=="
  , uncurry neqrel <$> setbop "!="
  , uncurry inrel <$> do
      l <- parsesimplesetexp
      p.reserved alloyish "in"
      r <- parsesetexp
      return (l,r)
  , notrel <$> (p.reserved alloyish "not" *> parsesimplerelexp)
  ]

parseqrel qstr = do
  p.reserved alloyish qstr
  var <- p.identifier alloyish
  parseop ":"
  baseexp <- parsesimplesetexp
  relexp <- p.braces alloyish parserelexp
  relexp <- return $ flip fmap relexp $ \vname ->
    if vname == var then nothing else just vname
  return (baseexp,relexp)

parserelexp
  = foldl1 (\x y -> p.try x p.<|> y) $
  [ uncurry andrel <$> relbop "&&"
  , uncurry orrel <$> relbop "||"
  , uncurry implyrel <$> relbop "=>"
  , uncurry iffrel <$> relbop "<=>"
  , uncurry qallrel <$> parseqrel "all"
  , uncurry qsomerel <$> parseqrel "some"
  , uncurry qonerel <$> parseqrel "one"
  , uncurry qlonerel <$> parseqrel "lone"
  , uncurry qnorel <$> parseqrel "no"
  , parsesimplerelexp
  ]

data setexp v
  = atomset v
  | noneset -- empty 1-ary relation
  | univset -- universe of 1-ary relations
  | identset -- binary identity relation
  | joinset       (setexp v) (setexp v)
  | prodset       (setexp v) (setexp v)
  | isectset      (setexp v) (setexp v)
  | unionset      (setexp v) (setexp v)
  | diffset       (setexp v) (setexp v)
  | closureset    (setexp v)
  | oneclosureset (setexp v)
  | transposeset  (setexp v)
  | filterset     (setexp v) (relexp (maybe v))
  | mapset        (setexp v) (setexp (maybe v))
  deriving (eq,show,read,functor)

data relexp v
  = inrel    (setexp v) (setexp v)
  | eqrel    (setexp v) (setexp v)
  | neqrel   (setexp v) (setexp v)
  | somerel  (setexp v)
  | norel    (setexp v)
  | lonerel  (setexp v)
  | onerel   (setexp v)
  | notrel   (relexp v)
  | andrel   (relexp v) (relexp v)
  | orrel    (relexp v) (relexp v)
  | implyrel (relexp v) (relexp v)
  | iffrel   (relexp v) (relexp v)
  | qallrel  (setexp v) (relexp (maybe v))
  | qsomerel (setexp v) (relexp (maybe v))
  | qonerel  (setexp v) (relexp (maybe v))
  | qlonerel (setexp v) (relexp (maybe v))
  | qnorel   (setexp v) (relexp (maybe v))
  deriving (eq,show,read,functor)

data env v dat = env
  { envvars     :: m.map t.text [[v]] -- relations
  , envuniverse :: [v]
  , envextra    :: m.map v dat
  } deriving (eq,show,read,functor)

data entry = entry
  { entname     :: t.text
  , entbasesets :: [t.text]
  , entedges    :: m.map t.text [t.text]
  , entdata     :: m.map t.text t.text
  } deriving (eq,show,read)

freshenvvar :: env v dat -> t.text
freshenvvar env = head $ filter (not . (`elem` m.keys (envvars env)))
                       $ scanl (<>) "_" (repeat "_")

applyentry :: entry -> env t.text (m.map t.text t.text) -> env t.text (m.map t.text t.text)
applyentry (entry name bases edges dat)
           (env{envvars=vars,envuniverse=univ,envextra=extra})
  = env
    { envvars = foldl (\x f -> f x) (m.insert name [[name]] vars)
                edgeupdates
    , envuniverse = (if name `elem` univ then [] else [name]) ++ univ
                  ++ (filter (not . (`elem` (name:univ))) $
                      nub $ join $ m.elems edges)
    , envextra = m.insert name dat extra
    }
  where
    edgeupdates = foldl1 (++) $
      [ do
        (k,v) <- m.assocs edges
        other <- v
        return $ flip m.alter k $ just . \case
          nothing -> [[name,other]]
          just es -> if [name,other] `elem` es
            then es else [name,other]:es
      , do
        b <- bases
        return $ flip m.alter b $ just . \case
          nothing -> [[name]]
          just es -> if [name] `elem` es
            then es else [name]:es
      ]

parseentry = do
  name <- (t.pack <$>) $ p.manytill (p.alphanum p.<|> p.oneof "_") $ p.try $ p.oneof ":"
  p.spaces
  basesets <- (map t.pack <$>) $ p.sepby (p.many1 $ p.alphanum p.<|> p.oneof "_") (p.many1 $ p.oneof " ")
  p.newline
  p.many p.newline
  p.string "edges:" >> p.newline
  edges <- (m.fromlistwith (++) <$>) $ p.many $ p.try $ do
    edgename <- (t.pack <$>) $ p.manytill (p.alphanum p.<|> p.oneof "_") p.space
    p.spaces
    targetname <- (t.pack <$>) $ p.manytill (p.alphanum p.<|> p.oneof "_") $ p.newline
    return (edgename,[targetname])
  p.many1 p.newline
  p.string "data:" >> p.newline
  attrs <- (m.fromlist <$>) $ p.many $ p.try $ do
    datakey <- (t.pack <$>) $ p.manytill (p.alphanum p.<|> p.oneof "_") $ p.char ':'
    p.newline
    datadata <- (t.pack <$>) $ p.manytill (p.anychar) $ p.try $ (p.newline >> p.newline >> return ()) p.<|> p.eof
    return (datakey,datadata)
  return entry{entname=name, entbasesets=basesets, entedges=edges, entdata=attrs}

safelast [] = nothing
safelast (x:[]) = just x
safelast (x:xs) = safelast xs

allbutlast [] = []
allbutlast (x:[]) = []
allbutlast (x:xs) = x:allbutlast xs

listjoin x y = do
  xrow <- x
  lastval <- maybetolist $ safelast xrow
  pref <- return $ allbutlast xrow
  yrow <- y
  case yrow of
    y:ys | y == lastval -> return $ pref ++ ys
    _ -> []

listoneclosure x = go [] x x
  where
    go _ [] _ = []
    go univ base x
      = base ++
        go (univ++base)
           (filter (not . (`elem` (univ++base))) (listjoin base x))
           x

evalsetexp :: eq v => setexp t.text -> env v dat -> maybe [[v]]
evalsetexp (atomset x) (env vars _ _) = m.lookup x vars
evalsetexp noneset _ = just []
evalsetexp univset (env _ univ _) = just $ do
  x <- univ
  return [x]
evalsetexp identset (env _ univ _) = just $ do
  x <- univ
  return [x,x]
evalsetexp (isectset x y) e
  = (\v -> filter (`elem` v)) <$> evalsetexp x e <*> evalsetexp y e
evalsetexp (unionset x y) e
  = (\x' y' -> x' ++ filter (not . (`elem` x')) y') <$> evalsetexp x e <*> evalsetexp y e
evalsetexp (diffset x y) e
  = (\x' y' -> filter (not . (`elem` y')) x') <$> evalsetexp x e <*> evalsetexp y e
evalsetexp (joinset x y) e = do
  x' <- evalsetexp x e
  y' <- evalsetexp y e
  return $ listjoin x' y'
evalsetexp (prodset x y) e = do
  x' <- evalsetexp x e
  y' <- evalsetexp y e
  return $ do { xv <- x'; yv <- y'; return $ xv ++ yv; }
evalsetexp (oneclosureset x) e = do
  x' <- evalsetexp x e
  return $ listoneclosure x'
evalsetexp (closureset x) e = evalsetexp (unionset identset (oneclosureset x)) e
evalsetexp (transposeset x) e = map reverse <$> evalsetexp x e
evalsetexp (filterset base rel) e = do
  base <- evalsetexp base e
  valname <- return $ freshenvvar e
  flip filterm base $ \val ->
    evalrelexp (frommaybe valname <$> rel) e{envvars=m.insert valname [val] (envvars e)}
evalsetexp (mapset base rel) e = do
  base <- evalsetexp base e
  valname <- return $ freshenvvar e
  ret <- flip mapm base $ \val ->
    evalsetexp (frommaybe valname <$> rel) e{envvars=m.insert valname [val] (envvars e)}
  return $ nub $ join ret

evalrelexp :: eq v => relexp t.text -> env v dat -> maybe bool
evalrelexp (inrel x y) e = do
  x' <- evalsetexp x e
  y' <- evalsetexp y e
  return $ all (`elem` y') x'
evalrelexp (eqrel x y) e = evalrelexp (andrel (inrel x y) (inrel y x)) e
evalrelexp (neqrel x y) e = evalrelexp (notrel (eqrel x y)) e
evalrelexp (somerel x) e = do
  x' <- evalsetexp x e
  return $ case x' of
    [] -> false
    _  -> true
evalrelexp (norel x) e = do
  x' <- evalsetexp x e
  return $ case x' of
    [] -> true
    _  -> false
evalrelexp (lonerel x) e = do
  x' <- evalsetexp x e
  return $ case x' of
    [] -> true
    _:[] -> true
    _  -> false
evalrelexp (onerel x) e = do
  x' <- evalsetexp x e
  return $ case x' of
    _:[] -> true
    _  -> false
evalrelexp (notrel r) e = not <$> evalrelexp r e
evalrelexp (andrel x y) e = (&&) <$> evalrelexp x e <*> evalrelexp y e
evalrelexp (orrel x y) e = (||) <$> evalrelexp x e <*> evalrelexp y e
evalrelexp (implyrel x y) e = (\a b -> not a || b) <$> evalrelexp x e <*> evalrelexp y e
evalrelexp (iffrel x y) e = (==) <$> evalrelexp x e <*> evalrelexp y e
evalrelexp (qallrel base rel) e = do
  base <- evalsetexp base e
  valname <- return $ freshenvvar e
  (all id <$>) $ sequence $ base >>= \val ->
    return $ evalrelexp (frommaybe valname <$> rel)
                        e{envvars=m.insert valname [val] (envvars e)}
evalrelexp (qsomerel base rel) e = do
  base <- evalsetexp base e
  valname <- return $ freshenvvar e
  (any id <$>) $ sequence $ base >>= \val ->
    return $ evalrelexp (frommaybe valname <$> rel)
                        e{envvars=m.insert valname [val] (envvars e)}
evalrelexp (qonerel base rel) e = do
  base <- evalsetexp base e
  valname <- return $ freshenvvar e
  l <- fmap length $ filterm id $ base >>= \val ->
    return $ evalrelexp (frommaybe valname <$> rel)
                        e{envvars=m.insert valname [val] (envvars e)}
  return $ l == 1
evalrelexp (qlonerel base rel) e = do
  base <- evalsetexp base e
  valname <- return $ freshenvvar e
  l <- fmap length $ filterm id $ base >>= \val ->
    return $ evalrelexp (frommaybe valname <$> rel)
                        e{envvars=m.insert valname [val] (envvars e)}
  return $ l <= 1
evalrelexp (qnorel base rel) e = do
  base <- evalsetexp base e
  valname <- return $ freshenvvar e
  (not <$>) $ (any id <$>) $ sequence $ base >>= \val ->
    return $ evalrelexp (frommaybe valname <$> rel)
                        e{envvars=m.insert valname [val] (envvars e)}

defaultenv = env
  { envvars = m.fromlist []
  , envuniverse = []
  , envextra = m.fromlist []
  }

testenv = env
  { envvars = m.fromlist
            [ ("this", [["goodbye"]])
            , ("that", [["stuff"]])
            , ("hello", [["hello"]])
            , ("left", [["hello", "goodbye"],["goodbye","sad"]])
            , ("right", [["sad","happy"]])
            ]
  , envuniverse = ["hello","goodbye","stuff","sad","happy"]
  , envextra = m.fromlist $ zip (envuniverse testenv) (repeat ())
  }

getfiles = do
  currdir <- getcurrentdirectory
  contents <- getdirectorycontents currdir
  filter (not . isprefixof "." . takebasename) <$> filterm doesfileexist contents

whileeither_ :: monad m => m (either a b) -> (a -> m ()) -> (b -> m ()) -> m ()
whileeither_ cond lop rop = do
  cond' <- cond
  case cond' of
    left lval -> lop lval
    right rval -> rop rval >> whileeither_ cond lop rop

linejoin [] = ""
linejoin ls = foldl1 (\x y -> x <> "\n" <> y) ls

prefixwith s = linejoin . map (s <>) . t.lines
indent = prefixwith "  "

main :: io ()
main = do
  files <- getfiles
  -- mapm putstrln files
  files <- sequence $ map (flip openfile readmode) files
  files <- sequence $ map hgetcontents files
  entries <- return $ sequence $ map (p.parse parseentry "") files
  putstrln $ show entries
  (right entries) <- return entries
  env <- return $ foldl (flip applyentry) defaultenv entries
  putstrln "\n\n-----------------\n"
  -- putstrln $ show env
  -- env <- return $ testenv
  expline <- return $
       p.parse (p.try (left <$> (p.reserved alloyish "setexp" *> parsesetexp <* p.eof))
                p.<|> (right <$> (p.reserved alloyish "relexp" *> parserelexp <* p.eof)))
               "" <$> (putstr "> " >> hflush stdout >> getline)
  step <- return $ expline >>= \case
    left err -> putstrln $ "parse error: " ++ show err
    right x -> do
      putstrln $ show x
      case x of
        left x -> do
          x <- return $ t.pack <$> x
          putstrln $ case evalsetexp x env of
            nothing -> "error"
            just items -> t.unpack $ t.unlines $ do
              [item] <- items
              foldl1 (++) $ [
                return $ item <> ":"
                              <> (foldl (\x y -> x <> " " <> y) ""
                                        $ sort $ map fst $ filter (([item] `elem`) . snd)
                                        $ m.assocs $ envvars env)
                , do
                  edges <- return $ map (\ (k,v) -> (k,join v))
                                  $ filter ((>= 1) . length . snd)
                                  $ map (\ (k,v) -> (k, filter ((>= 1) . length) v))
                                  $ map (\ (k,v) -> (k,map tail $ filter (([item] `isprefixof`)) v))
                                  $ m.assocs $ envvars env
                  dat <- return $ (\ (k,v) -> [k <> ":", indent $ prefixwith "-> " v]) =<< (sort $ map (\ (k,v) -> (k, linejoin v)) $ edges)
                  map indent dat
                , do
                  (just dat) <- return $ m.lookup item $ envextra env
                  dat <- return $ sort (m.assocs dat)
                                >>= \ (k,v) -> [k <> ":",
                                                indent v]
                  map indent dat
                ]
        right x -> do
          x <- return $ t.pack <$> x
          putstrln $ maybe "error" show $ evalrelexp x env
  sequence_ $ repeat step

  -- whileeither_ expline (\_ -> putstrln "done.") $ 


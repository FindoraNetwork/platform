<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: wasm.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: wasm.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>let imports = {};
imports['__wbindgen_placeholder__'] = module.exports;
let wasm;
const { TextDecoder } = require(String.raw`util`);

let cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });

cachedTextDecoder.decode();

let cachegetUint8Memory0 = null;
function getUint8Memory0() {
    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {
        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachegetUint8Memory0;
}

function getStringFromWasm0(ptr, len) {
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}

const heap = new Array(32).fill(undefined);

heap.push(undefined, null, true, false);

let heap_next = heap.length;

function addHeapObject(obj) {
    if (heap_next === heap.length) heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];

    heap[idx] = obj;
    return idx;
}

function getObject(idx) { return heap[idx]; }

let WASM_VECTOR_LEN = 0;

let cachegetNodeBufferMemory0 = null;
function getNodeBufferMemory0() {
    if (cachegetNodeBufferMemory0 === null || cachegetNodeBufferMemory0.buffer !== wasm.memory.buffer) {
        cachegetNodeBufferMemory0 = Buffer.from(wasm.memory.buffer);
    }
    return cachegetNodeBufferMemory0;
}

function passStringToWasm0(arg, malloc) {

    const len = Buffer.byteLength(arg);
    const ptr = malloc(len);
    getNodeBufferMemory0().write(arg, ptr, len);
    WASM_VECTOR_LEN = len;
    return ptr;
}

let cachegetInt32Memory0 = null;
function getInt32Memory0() {
    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {
        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);
    }
    return cachegetInt32Memory0;
}

function dropObject(idx) {
    if (idx &lt; 36) return;
    heap[idx] = heap_next;
    heap_next = idx;
}

function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
}

function makeMutClosure(arg0, arg1, dtor, f) {
    const state = { a: arg0, b: arg1, cnt: 1 };
    const real = (...args) => {
        // First up with a closure we increment the internal reference
        // count. This ensures that the Rust closure environment won't
        // be deallocated while we're invoking it.
        state.cnt++;
        const a = state.a;
        state.a = 0;
        try {
            return f(a, state.b, ...args);
        } finally {
            if (--state.cnt === 0) wasm.__wbindgen_export_2.get(dtor)(a, state.b);
            else state.a = a;
        }
    };
    real.original = state;
    return real;
}
function __wbg_adapter_20(arg0, arg1, arg2) {
    wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__hb52d011baeb37d05(arg0, arg1, addHeapObject(arg2));
}

const u32CvtShim = new Uint32Array(2);

const uint64CvtShim = new BigUint64Array(u32CvtShim.buffer);
/**
* Create a relative transaction reference as a JSON string. Relative txo references are offset
* backwards from the operation they appear in -- 0 is the most recent, (n-1) is the first output
* of the transaction.
*
* References are used when constructing a transaction because the absolute transaction number
* has not yet been assigned.
*
* # Arguments
* @param {BigInt} idx -  Relative Txo (transaction output) SID.
* @returns {string}
*/
module.exports.create_relative_txo_ref = function(idx) {
    try {
        uint64CvtShim[0] = idx;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.create_relative_txo_ref(8, low0, high0);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        return getStringFromWasm0(r0, r1);
    } finally {
        wasm.__wbindgen_free(r0, r1);
    }
};

/**
* Create an absolute transaction reference as a JSON string.
* # Arguments
* @param {BigInt} idx -  Txo (transaction output) SID.
* @returns {string}
*/
module.exports.create_absolute_txo_ref = function(idx) {
    try {
        uint64CvtShim[0] = idx;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        wasm.create_absolute_txo_ref(8, low0, high0);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        return getStringFromWasm0(r0, r1);
    } finally {
        wasm.__wbindgen_free(r0, r1);
    }
};

/**
* Standard TransferType variant for txn builder.
* Returns a token as a string signifying that the Standard policy should be used when evaluating the transaction.
* @returns {string}
*/
module.exports.standard_transfer_type = function() {
    try {
        wasm.standard_transfer_type(8);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        return getStringFromWasm0(r0, r1);
    } finally {
        wasm.__wbindgen_free(r0, r1);
    }
};

/**
* Debt swap TransferType variant for txn builder.
* Returns a token as a string signifying that the DebtSwap policy should be used when evaluating the transaction.
* @returns {string}
*/
module.exports.debt_transfer_type = function() {
    try {
        wasm.debt_transfer_type(8);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        return getStringFromWasm0(r0, r1);
    } finally {
        wasm.__wbindgen_free(r0, r1);
    }
};

/**
* Generates random base64 encoded asset type string. Used in asset definitions.
* @see {@link WasmTransactionBuilder#add_operation_create_asset} for instructions on how to define an asset with a new
* asset type
* @returns {string}
*/
module.exports.random_asset_type = function() {
    try {
        wasm.random_asset_type(8);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        return getStringFromWasm0(r0, r1);
    } finally {
        wasm.__wbindgen_free(r0, r1);
    }
};

/**
* Given a serialized state commitment and transation, returns true if the transaction correctly
* hashes up to the state commitment and false otherwise.
* @param {string} state_commitment - string representating the state commitment.
* @param {string} authenticated_txn - string representating the transaction.
* @see {@link get_transaction} for instructions on fetching a transaction from the ledger.
* @see {@link get_state_commitment} for instructions on fetching a ledger state commitment.
* @returns {boolean}
*/
module.exports.verify_authenticated_txn = function(state_commitment, authenticated_txn) {
    var ptr0 = passStringToWasm0(state_commitment, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    var ptr1 = passStringToWasm0(authenticated_txn, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len1 = WASM_VECTOR_LEN;
    var ret = wasm.verify_authenticated_txn(ptr0, len0, ptr1, len1);
    return ret !== 0;
};

/**
* Performs a simple loan repayment fee calculation.
*
* The returned fee is a fraction of the `outstanding_balance`
* where the interest rate is expressed as a fraction `ir_numerator` / `ir_denominator`.
* Used in the Lending Demo.
* @param {BigInt} ir_numerator - interest rate numerator
* @param {BigInt} ir_denominator - interest rate denominator
* @param {BigInt] outstanding_balance -  amount of outstanding debt
* @returns {BigInt}
*/
module.exports.calculate_fee = function(ir_numerator, ir_denominator, outstanding_balance) {
    uint64CvtShim[0] = ir_numerator;
    const low0 = u32CvtShim[0];
    const high0 = u32CvtShim[1];
    uint64CvtShim[0] = ir_denominator;
    const low1 = u32CvtShim[0];
    const high1 = u32CvtShim[1];
    uint64CvtShim[0] = outstanding_balance;
    const low2 = u32CvtShim[0];
    const high2 = u32CvtShim[1];
    wasm.calculate_fee(8, low0, high0, low1, high1, low2, high2);
    var r0 = getInt32Memory0()[8 / 4 + 0];
    var r1 = getInt32Memory0()[8 / 4 + 1];
    u32CvtShim[0] = r0;
    u32CvtShim[1] = r1;
    const n3 = uint64CvtShim[0];
    return n3;
};

/**
* Returns an address to use for cancelling debt tokens in a debt swap.
* @returns {XfrPublicKey}
*/
module.exports.get_null_pk = function() {
    var ret = wasm.get_null_pk();
    return XfrPublicKey.__wrap(ret);
};

/**
* Create memo needed for debt token asset types. The memo will be parsed by the policy evalautor to ensure
* that all payment and fee amounts are correct.
* @param {BigInt} ir_numerator  - interest rate numerator
* @param {BigInt} ir_denominator - interest rate denominator
* @param {string} fiat_code - base64 string representing asset type used to pay off the loan
* @param {BigInt} loan_amount - loan amount
* @returns {string}
*/
module.exports.create_debt_memo = function(ir_numerator, ir_denominator, fiat_code, loan_amount) {
    try {
        uint64CvtShim[0] = ir_numerator;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        uint64CvtShim[0] = ir_denominator;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        var ptr2 = passStringToWasm0(fiat_code, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len2 = WASM_VECTOR_LEN;
        uint64CvtShim[0] = loan_amount;
        const low3 = u32CvtShim[0];
        const high3 = u32CvtShim[1];
        wasm.create_debt_memo(8, low0, high0, low1, high1, ptr2, len2, low3, high3);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        return getStringFromWasm0(r0, r1);
    } finally {
        wasm.__wbindgen_free(r0, r1);
    }
};

function _assertClass(instance, klass) {
    if (!(instance instanceof klass)) {
        throw new Error(`expected instance of ${klass.name}`);
    }
    return instance.ptr;
}
/**
* Create a blind asset record.
* @param {BigInt} amount - asset amount to store in the record
* @param {string} code -  base64 string representing the token code of the asset to be stored in the record
* @param {XfrPublicKey} pk -  XfrPublicKey representing the record owner
* @param {bool} conf_amount - boolean indicating whether the asset amount should be private
* @param {bool} conf_type - boolean indicating whether the asset type should be private
* @see {@link WasmTransactionBuilder#add_operation_issue_asset} for instructions on how to use
* blind asset records to issue assets on the ledger.
* @returns {string}
*/
module.exports.create_blind_asset_record = function(amount, code, pk, conf_amount, conf_type) {
    try {
        uint64CvtShim[0] = amount;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        var ptr1 = passStringToWasm0(code, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len1 = WASM_VECTOR_LEN;
        _assertClass(pk, XfrPublicKey);
        wasm.create_blind_asset_record(8, low0, high0, ptr1, len1, pk.ptr, conf_amount, conf_type);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        return getStringFromWasm0(r0, r1);
    } finally {
        wasm.__wbindgen_free(r0, r1);
    }
};

/**
* Decode (open) a blind asset record expressed as a JSON string using the given key pair.
* If successful returns a JSON encoding of the serialized open asset record.
* @param {string} blind_asset_record - String representating the blind asset record.
* @param {XfrKeyPair} key - Key pair of the asset record owner.
*
* TODO Add advice for resolving the errors to the error messages when possible
* @throws Could not deserialize blind asset record
* @throws Could not open asset record
* @see {@link WasmTransferOperationBuilder#add_input) for instructions on how to construct transfers with opened asset
* records.
* @returns {string}
*/
module.exports.open_blind_asset_record = function(blind_asset_record, key) {
    try {
        var ptr0 = passStringToWasm0(blind_asset_record, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        _assertClass(key, XfrKeyPair);
        wasm.open_blind_asset_record(8, ptr0, len0, key.ptr);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        return getStringFromWasm0(r0, r1);
    } finally {
        wasm.__wbindgen_free(r0, r1);
    }
};

/**
* Extract the public key as a string from a transfer key pair.
* @returns {string}
*/
module.exports.get_pub_key_str = function(key_pair) {
    try {
        _assertClass(key_pair, XfrKeyPair);
        wasm.get_pub_key_str(8, key_pair.ptr);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        return getStringFromWasm0(r0, r1);
    } finally {
        wasm.__wbindgen_free(r0, r1);
    }
};

/**
* Extract the private key as a string from a transfer key pair.
* @returns {string}
*/
module.exports.get_priv_key_str = function(key_pair) {
    try {
        _assertClass(key_pair, XfrKeyPair);
        wasm.get_priv_key_str(8, key_pair.ptr);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        return getStringFromWasm0(r0, r1);
    } finally {
        wasm.__wbindgen_free(r0, r1);
    }
};

/**
* Create a new transfer key pair.
* @returns {XfrKeyPair}
*/
module.exports.new_keypair = function() {
    var ret = wasm.new_keypair();
    return XfrKeyPair.__wrap(ret);
};

/**
* Return base64 encoded representation of an XfrPublicKey
* @returns {string}
*/
module.exports.public_key_to_base64 = function(key) {
    try {
        _assertClass(key, XfrPublicKey);
        wasm.public_key_to_base64(8, key.ptr);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        return getStringFromWasm0(r0, r1);
    } finally {
        wasm.__wbindgen_free(r0, r1);
    }
};

/**
* Express a transfer key pair as a hex-encoded string.
* To decode the string, use `keypair_from_str` function.
* @returns {string}
*/
module.exports.keypair_to_str = function(key_pair) {
    try {
        _assertClass(key_pair, XfrKeyPair);
        wasm.keypair_to_str(8, key_pair.ptr);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        return getStringFromWasm0(r0, r1);
    } finally {
        wasm.__wbindgen_free(r0, r1);
    }
};

/**
* Construct a transfer key pair from a hex-encoded string.
* The encode a key pair, use `keypair_to_str`
* @returns {XfrKeyPair}
*/
module.exports.keypair_from_str = function(str) {
    var ptr0 = passStringToWasm0(str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    var ret = wasm.keypair_from_str(ptr0, len0);
    return XfrKeyPair.__wrap(ret);
};

/**
* @returns {string}
*/
module.exports.generate_elgamal_keys = function() {
    try {
        wasm.generate_elgamal_keys(8);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        return getStringFromWasm0(r0, r1);
    } finally {
        wasm.__wbindgen_free(r0, r1);
    }
};

/**
* Return the SHA256 signature of the given string as a hex-encoded
* string.
* @returns {string}
*/
module.exports.sha256str = function(str) {
    try {
        var ptr0 = passStringToWasm0(str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.sha256str(8, ptr0, len0);
        var r0 = getInt32Memory0()[8 / 4 + 0];
        var r1 = getInt32Memory0()[8 / 4 + 1];
        return getStringFromWasm0(r0, r1);
    } finally {
        wasm.__wbindgen_free(r0, r1);
    }
};

/**
* Sign the given message using the given transfer key pair.
* @returns {any}
*/
module.exports.sign = function(key_pair, message) {
    _assertClass(key_pair, XfrKeyPair);
    var ptr0 = passStringToWasm0(message, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    var ret = wasm.sign(key_pair.ptr, ptr0, len0);
    return takeObject(ret);
};

/**
* Submit a transaction to the ledger and return a promise for the
* ledger\'s eventual response. The transaction will be enqueued for
* validation. If it is valid, it will eventually be committed to the
* ledger.
*
* To determine whether or not the transaction has been committed to the ledger,
* query the ledger by transaction handle.
*
* Contained in the response of `submit_transaction` is a `TransactionHandle` that can be used to
* query the status of the transaction.
* @param {string} path - Submission server path (e.g. `https://localhost:8669`)
* @param {transaction_str} - JSON-encoded transaction string.
*
* @see {@link get_txn_status} for information about transaction statuses.
* TODO Design and implement a notification mechanism.
* @returns {any}
*/
module.exports.submit_transaction = function(path, transaction_str) {
    var ptr0 = passStringToWasm0(path, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    var ptr1 = passStringToWasm0(transaction_str, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len1 = WASM_VECTOR_LEN;
    var ret = wasm.submit_transaction(ptr0, len0, ptr1, len1);
    return takeObject(ret);
};

/**
* Given a transaction ID, returns a promise for the transaction status.
* @returns {any}
*/
module.exports.get_txn_status = function(path, handle) {
    var ptr0 = passStringToWasm0(path, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    var ptr1 = passStringToWasm0(handle, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len1 = WASM_VECTOR_LEN;
    var ret = wasm.get_txn_status(ptr0, len0, ptr1, len1);
    return takeObject(ret);
};

/**
* If successful, return a promise that will eventually provide a
* JsValue describing an unspent transaction output (UTXO).
* Otherwise, return \'not found\'. The request fails if the txo uid
* has been spent or the transaction index does not correspond to a
* transaction.
* @param {string} path - Address of ledger server
* @param {BigInt} index - UTXO index
*
* TODO Provide an example (test case) that demonstrates how to
* handle the error in the case of an invalid transaction index.
* TODO Rename this function get_utxo
* @returns {any}
*/
module.exports.get_txo = function(path, index) {
    var ptr0 = passStringToWasm0(path, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    uint64CvtShim[0] = index;
    const low1 = u32CvtShim[0];
    const high1 = u32CvtShim[1];
    var ret = wasm.get_txo(ptr0, len0, low1, high1);
    return takeObject(ret);
};

/**
* If successful, return a promise that will eventually provide a
* JsValue describing a transaction.
* Otherwise, return \'not found\'. The request fails if the transaction index does not correspond
* to a transaction.
*
* @param {String} path - Ledger server path
* @param {BigInt} index - transaction index.
*
* TODO Provide an example (test case) that demonstrates how to
* handle the error in the case of an invalid transaction index.
* @returns {any}
*/
module.exports.get_transaction = function(path, index) {
    var ptr0 = passStringToWasm0(path, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    uint64CvtShim[0] = index;
    const low1 = u32CvtShim[0];
    const high1 = u32CvtShim[1];
    var ret = wasm.get_transaction(ptr0, len0, low1, high1);
    return takeObject(ret);
};

/**
* Returns a JSON-encoded version of the state commitment of a running ledger. This is used to
* check the authenticity of transactions and blocks.
* @returns {any}
*/
module.exports.get_state_commitment = function(path) {
    var ptr0 = passStringToWasm0(path, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    var ret = wasm.get_state_commitment(ptr0, len0);
    return takeObject(ret);
};

/**
* If successful, returns a promise that will eventually provide a
* JsValue describing an asset token. Otherwise, returns \'not found\'.
* The request fails if the given asset name does not correspond to
* an asset.
* @param {string} path: Address of ledger server
* @param {string} name: base64-encoded asset token string
*
* TODO Provide an example (test case) that demonstrates how to
* handle the error in the case of an undefined asset.
* @returns {any}
*/
module.exports.get_asset_token = function(path, name) {
    var ptr0 = passStringToWasm0(path, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    var ptr1 = passStringToWasm0(name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len1 = WASM_VECTOR_LEN;
    var ret = wasm.get_asset_token(ptr0, len0, ptr1, len1);
    return takeObject(ret);
};

let stack_pointer = 32;

function addBorrowedObject(obj) {
    if (stack_pointer == 1) throw new Error('out of js stack');
    heap[--stack_pointer] = obj;
    return stack_pointer;
}
/**
* Generate a proof that a user has committed to the given attribute
* value.
* @returns {any}
*/
module.exports.get_proof = function(attribute) {
    uint64CvtShim[0] = attribute;
    const low0 = u32CvtShim[0];
    const high0 = u32CvtShim[1];
    var ret = wasm.get_proof(low0, high0);
    return takeObject(ret);
};

/**
* Attests credential attribute with proof as an input.
*
* Proves in zero knowledge that a simple equality or greater than relation is true without revealing the terms.
*
* In the P2P Lending app, the user has the option to save the proof for future use.
* * If the proof exists, use this function for credentialing.
* * Otherwise, use `attest_without_proof` for credentialing.
*
* # Arguments
* * `attribute`: credential attribute value.
* * `requirement`: required value.
* * `requirement_type`: relation between the real and required values. See `RelationType` for options.
* * `proof_jsvalue`: JsValue representing the proof.
* @returns {boolean}
*/
module.exports.attest_with_proof = function(attribute, requirement, requirement_type, proof_jsvalue) {
    uint64CvtShim[0] = attribute;
    const low0 = u32CvtShim[0];
    const high0 = u32CvtShim[1];
    uint64CvtShim[0] = requirement;
    const low1 = u32CvtShim[0];
    const high1 = u32CvtShim[1];
    var ret = wasm.attest_with_proof(low0, high0, low1, high1, requirement_type, addHeapObject(proof_jsvalue));
    return ret !== 0;
};

/**
* Attests credential attribute without proof as an input.
*
* Creates an issuer and user for the purpose of generating a proof in zero knowledge
* that a simple equality or greater than relationship is true.
*
* In the P2P Lending app, the user has the option to save the proof for future use.
* * If the proof exists, use `attest_with_proof` for credentialing.
* * Otherwise, use this function for credentialing.
*
* # Arguments
* * `attribute`: credential attribute value.
* * `requirement`: required value.
* * `requirement_type`: relation between the real and required values. See `RelationType` for options.
* @returns {boolean}
*/
module.exports.attest_without_proof = function(attribute, requirement, requirement_type) {
    uint64CvtShim[0] = attribute;
    const low0 = u32CvtShim[0];
    const high0 = u32CvtShim[1];
    uint64CvtShim[0] = requirement;
    const low1 = u32CvtShim[0];
    const high1 = u32CvtShim[1];
    var ret = wasm.attest_without_proof(low0, high0, low1, high1, requirement_type);
    return ret !== 0;
};

function handleError(e) {
    wasm.__wbindgen_exn_store(addHeapObject(e));
}
function __wbg_adapter_89(arg0, arg1, arg2, arg3) {
    wasm.wasm_bindgen__convert__closures__invoke2_mut__h0d1325c718c1b0bb(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));
}

function getArrayU8FromWasm0(ptr, len) {
    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
/**
* Relation types, used to represent the credential requirement types.
*/
module.exports.RelationType = Object.freeze({ Equal:0,AtLeast:1, });
/**
* Issuer structure.
* In the credentialing process, an issuer must sign the credential attribute to get it proved.
*/
class Issuer {

    static __wrap(ptr) {
        const obj = Object.create(Issuer.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_issuer_free(ptr);
    }
    /**
    * Create a new issuer, generating the key pair with the knowledge of the number of attributes.
    *
    * TODO Add an overview description of the anonymous credential
    * functions and how they work together.
    * @returns {Issuer}
    */
    static new(num_attr) {
        var ret = wasm.issuer_new(num_attr);
        return Issuer.__wrap(ret);
    }
    /**
    * Convert an Issuer to JsValue.
    * @returns {any}
    */
    jsvalue() {
        var ret = wasm.issuer_jsvalue(this.ptr);
        return takeObject(ret);
    }
    /**
    * Sign an attribute.
    * @returns {any}
    */
    sign_attribute(user_jsvalue, attribute) {
        try {
            uint64CvtShim[0] = attribute;
            const low0 = u32CvtShim[0];
            const high0 = u32CvtShim[1];
            var ret = wasm.issuer_sign_attribute(this.ptr, addBorrowedObject(user_jsvalue), low0, high0);
            return takeObject(ret);
        } finally {
            heap[stack_pointer++] = undefined;
        }
    }
}
module.exports.Issuer = Issuer;
/**
* Prover structure.
* In the credentialing process, a credential attribute must be proved by a prover.
*/
class Prover {

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_prover_free(ptr);
    }
    /**
    * Prove that an attribute meets the requirement and is true.
    * @returns {boolean}
    */
    static prove_attribute(proof_jsvalue, issuer_jsvalue, attribute, reveal_attribute, requirement, requirement_type) {
        try {
            uint64CvtShim[0] = attribute;
            const low0 = u32CvtShim[0];
            const high0 = u32CvtShim[1];
            uint64CvtShim[0] = requirement;
            const low1 = u32CvtShim[0];
            const high1 = u32CvtShim[1];
            var ret = wasm.prover_prove_attribute(addBorrowedObject(proof_jsvalue), addBorrowedObject(issuer_jsvalue), low0, high0, reveal_attribute, low1, high1, requirement_type);
            return ret !== 0;
        } finally {
            heap[stack_pointer++] = undefined;
            heap[stack_pointer++] = undefined;
        }
    }
}
module.exports.Prover = Prover;
/**
* User structure.
* In the credentialing process, a user must commit the credential attribute to get it proved.
*/
class User {

    static __wrap(ptr) {
        const obj = Object.create(User.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_user_free(ptr);
    }
    /**
    * Create a new user, generating the key pair using the issuer\'s
    * public key.
    * @returns {User}
    */
    static new(issuer, rand_seed) {
        _assertClass(issuer, Issuer);
        var ptr0 = passStringToWasm0(rand_seed, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        var ret = wasm.user_new(issuer.ptr, ptr0, len0);
        return User.__wrap(ret);
    }
    /**
    * Convert a User to JsValue.
    * @returns {any}
    */
    jsvalue() {
        var ret = wasm.user_jsvalue(this.ptr);
        return takeObject(ret);
    }
    /**
    * Commit an attribute with the issuer\'s signature.
    * @returns {any}
    */
    commit_attribute(issuer_jsvalue, sig, attribute, reveal_attribute) {
        try {
            uint64CvtShim[0] = attribute;
            const low0 = u32CvtShim[0];
            const high0 = u32CvtShim[1];
            var ret = wasm.user_commit_attribute(this.ptr, addBorrowedObject(issuer_jsvalue), addBorrowedObject(sig), low0, high0, reveal_attribute);
            return takeObject(ret);
        } finally {
            heap[stack_pointer++] = undefined;
            heap[stack_pointer++] = undefined;
        }
    }
}
module.exports.User = User;
/**
* Structure that allows users to construct arbitrary transactions.
*/
class WasmTransactionBuilder {

    static __wrap(ptr) {
        const obj = Object.create(WasmTransactionBuilder.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_wasmtransactionbuilder_free(ptr);
    }
    /**
    * Create a new transaction builder.
    * @returns {WasmTransactionBuilder}
    */
    static new() {
        var ret = wasm.wasmtransactionbuilder_new();
        return WasmTransactionBuilder.__wrap(ret);
    }
    /**
    * Wraps around TransactionBuilder to add an asset definition operation to a transaction builder instance.
    *
    * @param {XfrKeyPair} key_pair -  Issuer XfrKeyPair
    * @param {string} memo - Text field for asset definition
    * @param {string} token_code - Optional Base64 string representing the token code of the asset to be issued.
    * If empty, a token code will be chosen at random
    * @returns {WasmTransactionBuilder}
    */
    add_operation_create_asset(key_pair, memo, token_code) {
        _assertClass(key_pair, XfrKeyPair);
        var ptr0 = passStringToWasm0(memo, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        var ptr1 = passStringToWasm0(token_code, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len1 = WASM_VECTOR_LEN;
        var ret = wasm.wasmtransactionbuilder_add_operation_create_asset(this.ptr, key_pair.ptr, ptr0, len0, ptr1, len1);
        return WasmTransactionBuilder.__wrap(ret);
    }
    /**
    * Wraps around TransactionBuilder to add an asset issuance to a transaction builder instance.
    * @param {XfrKeyPair} key_pair  - Issuer XfrKeyPair
    * @param {string} elgamal_pub_key  - Optional tracking public key. Pass in serialized tracking key or \"\
    * @param {string} code - Base64 string representing the token code of the asset to be issued
    * @param {BigInt} seq_num - Issuance sequence number. Every subsequent issuance of a given asset type must have a higher sequence number than before
    * @param {BigInt} amount - Amount to be issued.
    * @returns {WasmTransactionBuilder}
    */
    add_basic_issue_asset(key_pair, elgamal_pub_key, code, seq_num, amount) {
        _assertClass(key_pair, XfrKeyPair);
        var ptr0 = passStringToWasm0(elgamal_pub_key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        var ptr1 = passStringToWasm0(code, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len1 = WASM_VECTOR_LEN;
        uint64CvtShim[0] = seq_num;
        const low2 = u32CvtShim[0];
        const high2 = u32CvtShim[1];
        uint64CvtShim[0] = amount;
        const low3 = u32CvtShim[0];
        const high3 = u32CvtShim[1];
        var ret = wasm.wasmtransactionbuilder_add_basic_issue_asset(this.ptr, key_pair.ptr, ptr0, len0, ptr1, len1, low2, high2, low3, high3);
        return WasmTransactionBuilder.__wrap(ret);
    }
    /**
    * Wraps around TransactionBuilder to add an asset issuance operation to a transaction builder instance.
    *
    * While add_basic_issue_asset constructs the blind asset record internally, this function
    * allows an issuer to pass in an externally constructed blind asset record. For complicated
    * transactions (e.g. issue and
    * transfers) the client must have a handle on the issuance record for subsequent operations.
    *
    * @param {XfrKeyPair} key_pair - Issuer XfrKeyPair
    * @param {string} code - Base64 string representing the token code of the asset to be issued
    * @param {BigInt} seq_num - Issuance sequence number. Every subsequent issuance of a given asset type must have a higher sequence number than before
    * @param {string} record - Issunace output (serialized blind asset record)
    * @see {@link create_blind_asset_record} for details on constructing blind asset records.
    * @see {@link random_asset_type} for details on generating new asset types.
    * @returns {WasmTransactionBuilder}
    */
    add_operation_issue_asset(key_pair, code, seq_num, record) {
        _assertClass(key_pair, XfrKeyPair);
        var ptr0 = passStringToWasm0(code, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        uint64CvtShim[0] = seq_num;
        const low1 = u32CvtShim[0];
        const high1 = u32CvtShim[1];
        var ptr2 = passStringToWasm0(record, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len2 = WASM_VECTOR_LEN;
        var ret = wasm.wasmtransactionbuilder_add_operation_issue_asset(this.ptr, key_pair.ptr, ptr0, len0, low1, high1, ptr2, len2);
        return WasmTransactionBuilder.__wrap(ret);
    }
    /**
    * Adds a serialized operation to a WasmTransactionBuilder instance
    * @param {string} op -  a JSON-serialized operation (i.e. a transfer operation)
    * @see {@link WasmTransferOperationBuilder} for details on constructing a transfer operation
    * @returns {WasmTransactionBuilder}
    */
    add_operation(op) {
        var ptr0 = passStringToWasm0(op, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        var ret = wasm.wasmtransactionbuilder_add_operation(this.ptr, ptr0, len0);
        return WasmTransactionBuilder.__wrap(ret);
    }
    /**
    * Extract the serialized form of a transaction.
    *
    * TODO Develop standard terminology for Javascript functions that may throw errors.
    * @returns {string}
    */
    transaction() {
        try {
            wasm.wasmtransactionbuilder_transaction(8, this.ptr);
            var r0 = getInt32Memory0()[8 / 4 + 0];
            var r1 = getInt32Memory0()[8 / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_free(r0, r1);
        }
    }
}
module.exports.WasmTransactionBuilder = WasmTransactionBuilder;
/**
* Structure that enables clients to construct complex transfers.
*/
class WasmTransferOperationBuilder {

    static __wrap(ptr) {
        const obj = Object.create(WasmTransferOperationBuilder.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_wasmtransferoperationbuilder_free(ptr);
    }
    /**
    * Create a new transfer operation builder.
    * @returns {WasmTransferOperationBuilder}
    */
    static new() {
        var ret = wasm.wasmtransferoperationbuilder_new();
        return WasmTransferOperationBuilder.__wrap(ret);
    }
    /**
    * Wraps around TransferOperationBuilder to add an input to a transfer operation builder.
    * @param {string} txo_ref - Serialized Absolute or relative utxo reference
    * @param {string} oar - Serializez opened asset record to serve as transfer input. This record must exist on the
    * ledger for the transfer to be valid
    * @param {BigInt} amount - Amount of input record to transfer
    * @see {@link create_absolute_txo_ref} or {@link create_relative_txo_ref} for details on txo
    * references.
    * @see {@link open_blind_asset_record} for details on opening blind asset records.
    * @see {@link get_txo} for details on fetching blind asset records.
    * @returns {WasmTransferOperationBuilder}
    */
    add_input(txo_ref, oar, amount) {
        var ptr0 = passStringToWasm0(txo_ref, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        var ptr1 = passStringToWasm0(oar, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len1 = WASM_VECTOR_LEN;
        uint64CvtShim[0] = amount;
        const low2 = u32CvtShim[0];
        const high2 = u32CvtShim[1];
        var ret = wasm.wasmtransferoperationbuilder_add_input(this.ptr, ptr0, len0, ptr1, len1, low2, high2);
        return WasmTransferOperationBuilder.__wrap(ret);
    }
    /**
    * Wraps around TransferOperationBuilder to add an output to a transfer operation builder.
    *
    * @param {BigInt} amount - amount to transfer to the recipient
    * @param {XfrPublicKey} recipient - public key of the recipient
    * @param code {string} - String representaiton of the asset token code
    * @returns {WasmTransferOperationBuilder}
    */
    add_output(amount, recipient, code) {
        uint64CvtShim[0] = amount;
        const low0 = u32CvtShim[0];
        const high0 = u32CvtShim[1];
        _assertClass(recipient, XfrPublicKey);
        var ptr1 = passStringToWasm0(code, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len1 = WASM_VECTOR_LEN;
        var ret = wasm.wasmtransferoperationbuilder_add_output(this.ptr, low0, high0, recipient.ptr, ptr1, len1);
        return WasmTransferOperationBuilder.__wrap(ret);
    }
    /**
    * Wraps around TransferOperationBuilder to ensure the transfer inputs and outputs are balanced.
    * This function will add change outputs for all unspent portions of input records.
    * @returns {WasmTransferOperationBuilder}
    */
    balance() {
        var ret = wasm.wasmtransferoperationbuilder_balance(this.ptr);
        return WasmTransferOperationBuilder.__wrap(ret);
    }
    /**
    * Wraps around TransferOperationBuilder to finalize the transaction.
    *
    * # Arguments
    * @param {string} transfer_type - string representing the transfer type
    * @see {@link standard_transfer_type} or {@link debt_transfer_types} for details on transfer
    * types.
    * @returns {WasmTransferOperationBuilder}
    */
    create(transfer_type) {
        var ptr0 = passStringToWasm0(transfer_type, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        var ret = wasm.wasmtransferoperationbuilder_create(this.ptr, ptr0, len0);
        return WasmTransferOperationBuilder.__wrap(ret);
    }
    /**
    * Wraps around TransferOperationBuilder to add a signature to the transaction.
    *
    * All input owners must sign.
    *
    * @param {XfrKeyPair} kp - key pair of one of the input owners.
    * @returns {WasmTransferOperationBuilder}
    */
    sign(kp) {
        _assertClass(kp, XfrKeyPair);
        var ret = wasm.wasmtransferoperationbuilder_sign(this.ptr, kp.ptr);
        return WasmTransferOperationBuilder.__wrap(ret);
    }
    /**
    * Wraps around TransferOperationBuilder to extract an operation expression as JSON.
    * @returns {string}
    */
    transaction() {
        try {
            wasm.wasmtransferoperationbuilder_transaction(8, this.ptr);
            var r0 = getInt32Memory0()[8 / 4 + 0];
            var r1 = getInt32Memory0()[8 / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_free(r0, r1);
        }
    }
}
module.exports.WasmTransferOperationBuilder = WasmTransferOperationBuilder;
/**
*/
class XfrKeyPair {

    static __wrap(ptr) {
        const obj = Object.create(XfrKeyPair.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_xfrkeypair_free(ptr);
    }
    /**
    * @returns {XfrPublicKey}
    */
    get_pk() {
        var ret = wasm.xfrkeypair_get_pk(this.ptr);
        return XfrPublicKey.__wrap(ret);
    }
}
module.exports.XfrKeyPair = XfrKeyPair;
/**
*/
class XfrPublicKey {

    static __wrap(ptr) {
        const obj = Object.create(XfrPublicKey.prototype);
        obj.ptr = ptr;

        return obj;
    }

    free() {
        const ptr = this.ptr;
        this.ptr = 0;

        wasm.__wbg_xfrpublickey_free(ptr);
    }
}
module.exports.XfrPublicKey = XfrPublicKey;

module.exports.__wbindgen_json_parse = function(arg0, arg1) {
    var ret = JSON.parse(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
};

module.exports.__wbindgen_json_serialize = function(arg0, arg1) {
    const obj = getObject(arg1);
    var ret = JSON.stringify(obj === undefined ? null : obj);
    var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
};

module.exports.__wbindgen_object_drop_ref = function(arg0) {
    takeObject(arg0);
};

module.exports.__wbindgen_string_new = function(arg0, arg1) {
    var ret = getStringFromWasm0(arg0, arg1);
    return addHeapObject(ret);
};

module.exports.__wbg_instanceof_Window_04bba8b54ef81db0 = function(arg0) {
    var ret = getObject(arg0) instanceof Window;
    return ret;
};

module.exports.__wbg_fetch_3de3c7312223114f = function(arg0, arg1) {
    var ret = getObject(arg0).fetch(getObject(arg1));
    return addHeapObject(ret);
};

module.exports.__wbg_headers_ec2dccbbe29ab556 = function(arg0) {
    var ret = getObject(arg0).headers;
    return addHeapObject(ret);
};

module.exports.__wbg_newwithstrandinit_4394f5ba7917f979 = function(arg0, arg1, arg2) {
    try {
        var ret = new Request(getStringFromWasm0(arg0, arg1), getObject(arg2));
        return addHeapObject(ret);
    } catch (e) {
        handleError(e)
    }
};

module.exports.__wbindgen_object_clone_ref = function(arg0) {
    var ret = getObject(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_set_c2a0afd8b1103899 = function(arg0, arg1, arg2, arg3, arg4) {
    try {
        getObject(arg0).set(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));
    } catch (e) {
        handleError(e)
    }
};

module.exports.__wbindgen_cb_drop = function(arg0) {
    const obj = takeObject(arg0).original;
    if (obj.cnt-- == 1) {
        obj.a = 0;
        return true;
    }
    var ret = false;
    return ret;
};

module.exports.__wbg_call_183c0b733b35a027 = function(arg0, arg1) {
    try {
        var ret = getObject(arg0).call(getObject(arg1));
        return addHeapObject(ret);
    } catch (e) {
        handleError(e)
    }
};

module.exports.__wbg_newnoargs_4f6527054d7f1f1d = function(arg0, arg1) {
    var ret = new Function(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
};

module.exports.__wbg_call_283f884995dd89e7 = function(arg0, arg1, arg2) {
    try {
        var ret = getObject(arg0).call(getObject(arg1), getObject(arg2));
        return addHeapObject(ret);
    } catch (e) {
        handleError(e)
    }
};

module.exports.__wbg_new_fe8db0c1c4a81234 = function() {
    var ret = new Object();
    return addHeapObject(ret);
};

module.exports.__wbg_new_4b4544fc91638f83 = function(arg0, arg1) {
    try {
        var state0 = {a: arg0, b: arg1};
        var cb0 = (arg0, arg1) => {
            const a = state0.a;
            state0.a = 0;
            try {
                return __wbg_adapter_89(a, state0.b, arg0, arg1);
            } finally {
                state0.a = a;
            }
        };
        var ret = new Promise(cb0);
        return addHeapObject(ret);
    } finally {
        state0.a = state0.b = 0;
    }
};

module.exports.__wbg_resolve_a77ae6f272249390 = function(arg0) {
    var ret = Promise.resolve(getObject(arg0));
    return addHeapObject(ret);
};

module.exports.__wbg_then_695aa7e1c262b929 = function(arg0, arg1) {
    var ret = getObject(arg0).then(getObject(arg1));
    return addHeapObject(ret);
};

module.exports.__wbg_then_bca69bfa503c3179 = function(arg0, arg1, arg2) {
    var ret = getObject(arg0).then(getObject(arg1), getObject(arg2));
    return addHeapObject(ret);
};

module.exports.__wbg_globalThis_eb9027a878db64ad = function() {
    try {
        var ret = globalThis.globalThis;
        return addHeapObject(ret);
    } catch (e) {
        handleError(e)
    }
};

module.exports.__wbg_self_69a78003cf074413 = function() {
    try {
        var ret = self.self;
        return addHeapObject(ret);
    } catch (e) {
        handleError(e)
    }
};

module.exports.__wbg_window_db757fdea9443777 = function() {
    try {
        var ret = window.window;
        return addHeapObject(ret);
    } catch (e) {
        handleError(e)
    }
};

module.exports.__wbg_global_8efdae4f126ac8b4 = function() {
    try {
        var ret = global.global;
        return addHeapObject(ret);
    } catch (e) {
        handleError(e)
    }
};

module.exports.__wbindgen_is_undefined = function(arg0) {
    var ret = getObject(arg0) === undefined;
    return ret;
};

module.exports.__wbg_set_a6eff7b20941127b = function(arg0, arg1, arg2) {
    try {
        var ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));
        return ret;
    } catch (e) {
        handleError(e)
    }
};

module.exports.__wbg_getRandomValues_f5e14ab7ac8e995d = function(arg0, arg1, arg2) {
    getObject(arg0).getRandomValues(getArrayU8FromWasm0(arg1, arg2));
};

module.exports.__wbg_randomFillSync_d5bd2d655fdf256a = function(arg0, arg1, arg2) {
    getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));
};

module.exports.__wbg_self_1b7a39e3a92c949c = function() {
    try {
        var ret = self.self;
        return addHeapObject(ret);
    } catch (e) {
        handleError(e)
    }
};

module.exports.__wbg_require_604837428532a733 = function(arg0, arg1) {
    var ret = require(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
};

module.exports.__wbg_crypto_968f1772287e2df0 = function(arg0) {
    var ret = getObject(arg0).crypto;
    return addHeapObject(ret);
};

module.exports.__wbg_getRandomValues_a3d34b4fee3c2869 = function(arg0) {
    var ret = getObject(arg0).getRandomValues;
    return addHeapObject(ret);
};

module.exports.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
};

module.exports.__wbindgen_rethrow = function(arg0) {
    throw takeObject(arg0);
};

module.exports.__wbindgen_closure_wrapper943 = function(arg0, arg1, arg2) {
    var ret = makeMutClosure(arg0, arg1, 133, __wbg_adapter_20);
    return addHeapObject(ret);
};

const path = require('path').join(__dirname, 'wasm_bg.wasm');
const bytes = require('fs').readFileSync(path);

const wasmModule = new WebAssembly.Module(bytes);
const wasmInstance = new WebAssembly.Instance(wasmModule, imports);
wasm = wasmInstance.exports;
module.exports.__wasm = wasm;

</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Issuer.html">Issuer</a></li><li><a href="Prover.html">Prover</a></li><li><a href="User.html">User</a></li><li><a href="WasmTransactionBuilder.html">WasmTransactionBuilder</a></li><li><a href="WasmTransferOperationBuilder.html">WasmTransferOperationBuilder</a></li><li><a href="XfrKeyPair.html">XfrKeyPair</a></li><li><a href="XfrPublicKey.html">XfrPublicKey</a></li></ul><h3>Global</h3><ul><li><a href="global.html#attest_with_proof">attest_with_proof</a></li><li><a href="global.html#attest_without_proof">attest_without_proof</a></li><li><a href="global.html#calculate_fee">calculate_fee</a></li><li><a href="global.html#create_absolute_txo_ref">create_absolute_txo_ref</a></li><li><a href="global.html#create_blind_asset_record">create_blind_asset_record</a></li><li><a href="global.html#create_debt_memo">create_debt_memo</a></li><li><a href="global.html#create_relative_txo_ref">create_relative_txo_ref</a></li><li><a href="global.html#debt_transfer_type">debt_transfer_type</a></li><li><a href="global.html#generate_elgamal_keys">generate_elgamal_keys</a></li><li><a href="global.html#get_asset_token">get_asset_token</a></li><li><a href="global.html#get_null_pk">get_null_pk</a></li><li><a href="global.html#get_priv_key_str">get_priv_key_str</a></li><li><a href="global.html#get_proof">get_proof</a></li><li><a href="global.html#get_pub_key_str">get_pub_key_str</a></li><li><a href="global.html#get_state_commitment">get_state_commitment</a></li><li><a href="global.html#get_transaction">get_transaction</a></li><li><a href="global.html#get_txn_status">get_txn_status</a></li><li><a href="global.html#get_txo">get_txo</a></li><li><a href="global.html#keypair_from_str">keypair_from_str</a></li><li><a href="global.html#keypair_to_str">keypair_to_str</a></li><li><a href="global.html#new_keypair">new_keypair</a></li><li><a href="global.html#open_blind_asset_record">open_blind_asset_record</a></li><li><a href="global.html#public_key_to_base64">public_key_to_base64</a></li><li><a href="global.html#random_asset_type">random_asset_type</a></li><li><a href="global.html#RelationType">RelationType</a></li><li><a href="global.html#sha256str">sha256str</a></li><li><a href="global.html#sign">sign</a></li><li><a href="global.html#standard_transfer_type">standard_transfer_type</a></li><li><a href="global.html#submit_transaction">submit_transaction</a></li><li><a href="global.html#verify_authenticated_txn">verify_authenticated_txn</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Tue Mar 17 2020 19:42:06 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>

============ Policy DSL Design Rationale ==========

Findora is providing a platform for a wide range of privacy-preserving
financial instruments. To do this, we need to allow our customers to
encode the contractual logic of those instruments. There must be a
balance between:
  - Customizability -- how easily can different logic be implemented?
  - Predictability  -- how easy is it to understand the outcomes of a
    contract before agreeing to it?
  - Trustworthiness -- can users and auditors be sure that the ledger
    has enforced the contract terms, even though some transactions are
    confidential?

To achieve all three aspects, we are designing a Domain-Specific
Language (DSL) for describing contract-validation logic. We call each
specific contract-validation program a "policy".

Each asset type intrinsically has a policy attached to it when it is
defined. That policy governs how assets of that type are allowed to
be created or transferred.

Policies have some important functional design principles:
  - Policies can change the validity of transactions, but cannot
    change their effects. This means:
    - Any useful properties of transactions (eg, atomicity,
      no-double-spend, asset tracing) are preserved.
    - Policy evaluation logic can be separated from ledger update
      logic
  - Policies should have simple, limited control flow. In particular,
    no mutable variables and no loops. This means:
    - Automated analysis (eg, reachability, safety preconditions) is
      tractable (compare solidity analysis tools)
    - Estimating worst-case execution time is simple (and there are no
      infinite-loop policies)
    - The execution model can easily be handled by
      verified-computation and ZK proof systems.
    - Adding syntactic sugar for (local) mutability is easy.
    - Adding (constrained) loops to a "no loops" system is easier than
      figuring out which loops need to be forbidden/special-cased
      later.
  - Policies should describe how to build a transaction that satisfies
    them, if such a transaction exists. This means:
    - Policy-engine code can be reused between transaction building
      and validation
    - If you write a policy, there isn't *also* a need to write a
      custom transaction building routine.

Policies overlap with the idea of "smart contracts" in other
blockchain systems, most notably ethereum. However, smart contract
languages have various problems that can lead to major losses. There
have been losses caused by unintended contract deletion (link);
non-atomic actions and accounting errors leading to
"virtual double-spending" (link to TheDAO bug -- ELABORATE); oracle
programs shutting down due to changes in the price of Gas (link); and
more.

Findora policies avoid most of these by default. Since a policy can
only change the validity of a transaction, and transactions are
atomic, re-entrancy bugs are impossible. Since policies and attester
nodes are separate subsystems in our ledger, you never have an oracle
failure caused by the policy engine. Since policies are tied to asset
types, you can't make resources disappear by deleting a contract that
owns them.

There are all kinds of other bugs that can be caught/prevented by
adding more sophisticated analyses, but the biggest wins come from
*avoiding* these issues by design.


Example:
  - 2 banks trying to do a credit/equity swap for 2 years
    - every 2 months, the system is obligated to update the asset
      values
    - If asset value under a threshold, people may be obligated to pay
      more money

  "meticulously produced language"

